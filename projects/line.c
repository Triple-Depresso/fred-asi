#pragma config(Sensor, in1,    right_s,        sensorLineFollower)
#pragma config(Sensor, in2,    mid_s,          sensorLineFollower)
#pragma config(Sensor, in3,    left_s,         sensorLineFollower)
#pragma config(Sensor, dgtl1,  son_right,      sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  son_left,       sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  son_side,       sensorSONAR_cm)
#pragma config(Motor,  port1,           right_m,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mid_m,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           shooter_m1,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port4,           shooter_m2,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port5,           lower_intake_m, tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port6,           transfer_m,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port7,           bridge_m,      tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          left_m,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// coded by Fred, Feb. 2019
// find(control + F) '**' for potentential bugs

task main() {
	wait1Msec(3000);

	// variables
	bool mid_sen, right_sen, left_sen;
	int all_dark;
	all_dark = 0;

	while (true) {
		all_dark = 0;

		if (SensorValue(mid_s) > 1800) {
			mid_sen = true;
		}
		if (SensorValue(mid_s) < 1800) {
			mid_sen = false;
		}
		if (SensorValue(right_s) > 1800) {
			right_sen = true;
		}
		if (SensorValue(right_s) < 1800) {
			right_sen = false;
		}
		if (SensorValue(left_s) > 1800) {
			left_sen = true;
		}
		if (SensorValue(left_s) < 1800) {
			left_sen = false;
		}

		if (right_sen == true) {
			all_dark = (all_dark + 1);
			motor[right_m] = -65;
			wait1Msec(80);
			motor[right_m] = 0;
		}
		if (left_sen == true) {
			all_dark = (all_dark + 1);
			motor[left_m] = -65;
			wait1Msec(80);
			motor[left_m] = 0;
		}
		if (all_dark >= 2) {
			wait1Msec(3000);

			// turn 180
			motor[left_m] = 80;
			motor[right_m] = -80;
			wait1Msec(1200);
			motor[right_m] = 0;
			motor[left_m] = 0;

			wait1Msec(300);

			motor[mid_m] = 80;
			wait1Msec(900);
			motor[mid_m] = 0;

// -- ultrasonic stuff --
// ------------------------------------------------------
			wait1Msec(3000);

			int dis_left;
			int dis_right;
			int dis_side;

			// big net
			// Distance Horizontal Big
			// Distance Virtical Big
			int disHB, disVB;
			disHB = 151;
			disVB = 41;

			// small net
			// Distance Horizontal Small
			// Distance Virtical Small
			int disHS, disVS;
			disHS = 110;
			disVS = 105;

			// time it takes to shoot
			int time2b, time1b;
			time2b = 4000;
			time1b = 6000;

			// make the thing parallel
			while (SensorValue(son_left) != SensorValue(son_right)) {
				if (SensorValue(son_left) > SensorValue(son_right)) {
					motor[left_m] = 60;
					wait1Msec(100);
					motor[left_m] = 0;
				}
				if (SensorValue(son_right) > SensorValue(son_left)) {
					motor[right_m] = 60;
					wait1Msec(100);
					motor[right_m] = 0;
				}
			}

			while (true) {
		// VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
				dis_side = SensorValue(son_side);

				// check side	small
				if (dis_side == disHS) {
					while (true) {
						dis_left = SensorValue(son_left);
						dis_right = SensorValue(son_right);

						// check virtical distance small
						if (((dis_left + dis_right)/2) == disVS) {
							wait1Msec(150);
							while (true) {
								dis_left = SensorValue(son_left);
								dis_right = SensorValue(son_right);

								// check parallel small
								if (dis_left == dis_right) {
									// -- shoot 2 balls --
									motor[shooter_m1] = 120;
									motor[shooter_m2] = 120;
									//wait for shooter to rev up
									wait1Msec(2500);
									motor[transfer_m] = 120;

									wait1Msec(time2b);

									motor[transfer_m] = 0;
									motor[shooter_m1] = 0;
									motor[shooter_m2] = 0;

									wait1Msec(5000);
		// manuel


									motor[left_m] = 50;
									wait1Msec(300);
									motor[left_m] = 0;

									wait1Msec(500);

									motor[left_m] = 60;
									motor[right_m] = 60;
									wait1Msec(2300);
									motor[left_m] = 0;
									motor[right_m] = 0;


		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
		// -----------[start to aim at big net]---------------------
		// VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
									while (true) {
										dis_side = SensorValue(son_side);

										// check side
										if (dis_side == disHB) {
											while (true) {
												dis_left = SensorValue(son_left);
												dis_right = SensorValue(son_right);

												// check parallel
												if (dis_left == dis_right) {
													while (true) {
														dis_left = SensorValue(son_left);
														dis_right = SensorValue(son_right);

														// check forward distance
														if (((dis_left + dis_right)/2) == disVB) {

															// adjust so that the shooter is angled and aimed at the big net
															// left40 - right36
															while (true) {
																dis_left = SensorValue(son_left);
																dis_right = SensorValue(son_right);

																if ((dis_left == 40) && (dis_right == 37)) {
																	// -- shoot 1 balls --
																	motor[shooter_m1] = 120;
																	motor[shooter_m2] = 120;
																	//wait for shooter to rev up
																	wait1Msec(2500);
																	motor[transfer_m] = 120;

																	wait1Msec(time1b);

																	motor[transfer_m] = 0;
																	motor[shooter_m1] = 0;
																	motor[shooter_m2] = 0;

																	wait1Msec(10000);
																}
																// adjust the angeled shooter
																if (dis_left > 40) {
																	motor[left_m] = 40;
																	wait1Msec(80);
																	motor[left_m] = 0;
																}
																if (dis_left < 40) {
																	motor[left_m] = -40;
																	wait1Msec(80);
																	motor[left_m] = 0;
																}
																if (dis_right > 37) {
																	motor[right_m] = 40;
																	wait1Msec(80);
																	motor[right_m] = 0;
																}
																if (dis_right < 37) {
																	motor[right_m] = -40;
																	wait1Msec(80);
																	motor[right_m] = 0;
																}
															}
														}
														// adjust vitical big
														if (((dis_left + dis_right)/2) > disVB) {
															motor[left_m] = 50;
															motor[right_m] = 50;
															wait1Msec(100);
															motor[left_m] = 0;
															motor[right_m] = 0;
														}
														// adjust virtical big
														if (((dis_left + dis_right)/2) < disVB) {
															motor[left_m] = -50;
															motor[right_m] = -50;
															wait1Msec(100);
															motor[left_m] = 0;
															motor[right_m] = 0;
														}
													}
												}
												// adjust parallel big
												else if (dis_left > dis_right) {
													motor[left_m] = 50;
													wait1Msec(150);
													motor[left_m] = 0;
												}
												// adjust parallel big
												else if (dis_right > dis_left) {
													motor[right_m] = 50;
													wait1Msec(100);
													motor[right_m] = 0;
												}
											}
										}
										// adjust horizontal big
										else if (dis_side > disHB) {
											motor[mid_m] = 40;
											wait1Msec(100);
											motor[mid_m] = 0;
										}
										// adjust horizontal big
										else if (dis_side < disHB) {
											motor[mid_m] = -50;
											wait1Msec(150);
											motor[mid_m] = 0;
										}
									}
								}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
		// adjustments for small net
		// VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
								// adjust parallel small
								if (dis_left > dis_right) {
									motor[left_m] = 50;
									wait1Msec(80);
									motor[left_m] = 0;
									break;
								}
								// adjust parallel small
								if (dis_right > dis_left) {
									motor[right_m] = 50;
									wait1Msec(70);
									motor[right_m] = 0;
									break;
								}
							}
						}
						// adjust virtical small
						else if (((dis_left + dis_right)/2) > disVS) {
							motor[left_m] = 50;
							motor[right_m] = 50;
							wait1Msec(100);
							motor[left_m] = 0;
							motor[right_m] = 0;
						}
						// adjust virtical small
						else if (((dis_left + dis_right)/2) < disVS) {
							motor[left_m] = -50;
							motor[right_m] = -50;
							wait1Msec(100);
							motor[left_m] = 0;
							motor[right_m] = 0;
						}
					}
				}
				// adjust horizontal small
				else if (dis_side > disHS) {
					motor[mid_m] = 40;
					wait1Msec(80);
					motor[mid_m] = 0;
				}
				// adjust horizontal small
				else if (dis_side < disHS) {
					motor[mid_m] = -40;
					wait1Msec(80);
					motor[mid_m] = 0;
				}
			}
// ----------------------------------------------------------------
		}
		else {
			motor[left_m] = -40;
			motor[right_m] = -40;

			wait1Msec(50);

			motor[left_m] = 0;
			motor[right_m] = 0;
		}
	}
}
